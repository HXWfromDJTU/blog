# 数组的拓展

### 拓展运算符
1️⃣ 对数组可以方便地使用拓展运算符`...`，尤其在参数传递的时候，基本替代了传统的`arguments`对象和`Array.prototype.xxx.apply`借用数组方法
2️⃣ 数组的复制与合并: 使用`Array.prototype.concat`或者`...`拓展运算符，但需要注意这些操作都只是浅拷贝而已，修改后者内部的引用型数据，原对象也会被修改。
3️⃣ 拓展运算符 与 解构赋值结合
```js
const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest  // [2, 3, 4, 5]

const [first, ...rest] = [];
first // undefined
rest  // []

const [first, ...rest] = ["foo"];
first  // "foo"
rest   // []
```
4️⃣ 拓展运算符只能够放在数组的最后一位。
5️⃣ 字符串、类数组、generator等具备了Symbol.iterator属性的对象都可以被转换为数组。
6️⃣ Javascript原生对象虽然没有iterator接口，但是仍可以被拓展运算符所解析。

### 类静态方法
1️⃣ Array.form 可以将① 类数组对象 和 ② 具备Iterator接口的对象  转换为真正的数组
2️⃣ Array.of 接受多个值，然后把每个值依次作为数组元素，形成一个数组并返回

### 对象方法
1️⃣  copyWithin 在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。🚸 注意：本操作会修改当前数组
2️⃣  find() 和 findIndex() 都接受一个回调函数，用于检测是否符合调用者的条件，前者返回该元素本身，后者返回该元素所在位置。
3️⃣  fill(value[,start,end]) 使用一个值覆盖当前数组中所有位置上的值，还可以提供起始与终止位置
4️⃣  entries()，keys() 和 values() ，分别是对整体、键名、值得遍历，返回一个iterator对象
5️⃣  includes()  检测数组中是否含有某个元素
6️⃣  flat(times) 将一个数组中的数组”压扁“，也就是不让出现数组嵌套的情况。参数是压扁的层数，若想要全部压扁，可以考虑传入`Infinity`作为参数。但是注意，若是声明的数组中有下面👇其他注意点的第️1️⃣条的情况，flat会把“空值”清除掉。
7️⃣ flatMap 顾名思义，就是先将数组做一遍`Array.prototype.map`,而后再做一遍flat，记住哦，flat只做一次。

### 数组空位
1️⃣ `[1,2,,3,,4,5]`这样的写法也是合法的，但不建议。
2️⃣ 取值的时候，会返回一个undefined，也会占用一个元素。length属性也会计算这个位置。
3️⃣ 总结来说：空位占用空位，也占用下标，取值的话会取到undefined。只有使用 in操作符的时候不会等于任何值，也不会等于undefined
```js
undefined in [, , ,]  // false
```
4️⃣ 使用new关键字，传入一个数字作为数组长度参数，生成的数组就是这样的空位数组

### 参考文章
[阮一峰 ES6 数组的拓展]()