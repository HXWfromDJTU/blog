

![](/blog_assets/error_handle.png)   




### 如何处理  

`首先` 需要明确错误类型   

`然后` 明确错误类型之后，类型明确，则直接处理。若不明确，那就传递这个错误。    

程序错误，就直接崩溃    

不能够不处理，也不能够吃掉错误  

操作错误与编码错误   

### 同步与异步 & 调用栈与事件队列
Javascript语言同步的代码执行，是建立在一个调用栈的基础上的，而本文的核心Javascript
而异步操作的执行却是建立在一个事件队列的基础上的   

我们在处理异步操作的时候，执行栈中只有一个异步操作的回调压在栈中，一旦发生错误，也是无法通过Javascript语言内建的异常去追溯错误源头。   

同步错误与异步错误，都要处理，主要有三个场景   
1️⃣ 同步代码的错误  
2️⃣ 异步代码回调中的同步错误的捕获  
___  
### 发现异常
`错误的调用栈`   
与本次错误相关的上下文，比如几个关键变量的值   
若是决定不直接展示错误的内容，则可以为客户提供一个错误的编号，以便事后反馈可以还原当时现场。 
  
`吃掉了异常`
通常向一个node端的server请求http服务的时候，既没有收到成功响应，也没有收到失败响应，一直保持着链接，通常是因为server端代码抛出了错误但没有正常的进行捕获，导致这个请求的处理流被意外地中断掉了。   

`总是抛出继承自Error类的对象`   
允许我们去自定义一些新的异常对象，但是必须继承自原生的`Error`类。

`在异常对象上添加信息` 
```js
let err = new Error('Somethins went wrong when')
```

___  
### 异常传递   
我们可能在某一层级没有足够的信息去决定如何处理这个错误，例如在Data Access层，一个数据库查询发生了错误，在Data Access这一层并不知道该错误对于上层业务逻辑来说意味着什么，而仅仅知道这个查询失败了。   

所以要建立一种机制，将错误不断向上层传递，知道达到某个层级，有足够的信息去决定如何处理这个错误。    

一个异常若被catch了，便不会再继续回溯了，这时候我们称这个异常被处理了。   

使用同步 throw Error  

异步处理： 在callback内部，回调值  
```js
function（err,result){
  //注意第一个函数通常就是错误体本身   
}
```   

finally语句中的代码，会忽略try和catch中的return语句，不受其约束，而始终执行。
___
### 错误（Error）与 异常(Exception)
`错误`
通常用来表示广义的不正确、或不符合预期的情况；   

`异常`
具体指 JavaScript 或其他很多语言中提供的一种流程控制机制，以及在这个机制中被传递的异常对象。
  
##### 预期的异常
> 参数的不合法，前提条件不满足（开发人员能够猜到的可能发生的错误）

处理的时候，我们一般会把预期的异常，直接进行抛出，从而达到通知外层调用者的作用。   

##### 非预期的异常(错误)
> Javascript引擎的运行时异常  (开发人员你无法预期到的。比如，调用数据库或者读文件过程总发生的内部错误) ，一般这些错误是严重错误，会引起程序崩溃那种。   

非预期的错误，一般是由于我们开发人员(库开发人员，而不是调用人员)的编程错误，又或者是再底层的依赖库的错误，对于这样的错误，我们作为库开发人员，应该优先捕捉这些错误，然后再转化为预期的异常，再向外抛出。 

___

#### 实战中如何操作  
1️⃣ 确保每一个函数的功能与职责是单一的    
2️⃣ 使用`async/await`去表示异步代码，`try`、`catch`去处理近乎于同步代码的语句。  
3️⃣ `eventEmitter`模式去监听异步操作的句柄，绑定`onerror`事件。  
4️⃣ 使用`Typescript`去提前检查出来低级错误。       


##### 顶层捕获
```js
// 在进程的维度上直接监听
process.on('uncaughtException', (err) => {
  console.error(err);
});
```
当程序错误一抛出后，一直会不断上报，知道进程层面，我们可以在进程层面直接捕获。   


___
### summary
1️⃣ 在同步代码中，多个方法层层调用的时候，若当前层次发生错误，但在当前层次没有办法处理的时候，必须将这个错误沿着调用栈逆向抛出。    

2️⃣ 再异步操作的时候，我们推荐使用`async/await`的代码形式去构建业务，然后用`try-catch`去处理错误。   

3️⃣ 传递异常的时候，可以再异常对象上添加上下文环境（或者其他追踪信息）   

4️⃣ 在程序的边界设立统一的错误捕获机制，以至于`"兜住"`内部处理不了的错误，而引起程序的直接崩溃  