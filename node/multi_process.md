

# 多进程编程
### 历史演变
1️⃣ 单线程同步处理   QPS = 1/N;(N为请求数目)
2️⃣ 复制同一个进程进行处理  QPS = M/N;(M为最大进程数)
复制进程的开销十分大，而且大量重复无用的内容都被复制，效率极低
4️⃣ 多线程处理: QPS = M*L / N (L为一个进程中，一个线程所占该进程的比例) 
多线程处理比多进程处理已经减少了大量的开销，但在大并发的时候，大量的时间还是被浪费在上下文的切换之中，无法做到请打的伸缩性。例如并发量若来到C10K的时候，内存的耗用都会被暴露出来。
5️⃣ 事件驱动处理：
对`node`来说，所有的请求上下文都是统一的，她的稳定性是亟需解决的问题。

影响事件驱动服务模型性能的点，在于`CPU`的计算能力。如果能够解决掉`CPU`的利用问题，带来性能上的提升是客观的。

主从模式
主进程进行进程的调度，工作进程负责进行业务的处理。
`fork`进程是昂贵的操作，仍需要尽量少进行fork进程操作。
`fork`进程是为了解决多`CPU`的利用率问题，绝对不是用于应对高并发的问题。

我们都只知道 nodejs的执行时单线程的，但一个进程只能够使用一个CPU，所以我们通常 使用以下三种方式去实现：
* 同一台机器上部署多个Node服务，使用不同的端口，然后使用nginx负载均衡转发到不同的Node服务器上
* 使用Node自带的`child_process`和`cluster`模块实现进程间的通信，

`child_process` 模块

### IPC
IPC 也就是我们常说的`inter process communition`