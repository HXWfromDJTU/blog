

# 多进程编程
### 历史演变
1️⃣ 单线程同步处理   QPS = 1/N;(N为请求数目)
2️⃣ 复制同一个进程进行处理  QPS = M/N;(M为最大进程数)
复制进程的开销十分大，而且大量重复无用的内容都被复制，效率极低
4️⃣ 多线程处理: QPS = M*L / N (L为一个进程中，一个线程所占该进程的比例) 
多线程处理比多进程处理已经减少了大量的开销，但在大并发的时候，大量的时间还是被浪费在上下文的切换之中，无法做到请打的伸缩性。例如并发量若来到C10K的时候，内存的耗用都会被暴露出来。
5️⃣ 事件驱动处理：
对`node`来说，所有的请求上下文都是统一的，她的稳定性是亟需解决的问题。

影响事件驱动服务模型性能的点，在于`CPU`的计算能力。如果能够解决掉`CPU`的利用问题，带来性能上的提升是客观的。

主从模式
主进程进行进程的调度，工作进程负责进行业务的处理。
`fork`进程是昂贵的操作，仍需要尽量少进行fork进程操作。
`fork`进程是为了解决多`CPU`的利用率问题，绝对不是用于应对高并发的问题。

我们都只知道 nodejs的执行时单线程的，但一个进程只能够使用一个CPU，所以我们通常 使用以下三种方式去实现：
* 同一台机器上部署多个Node服务，使用不同的端口，然后使用nginx负载均衡转发到不同的Node服务器上
* 使用Node自带的`child_process`和`cluster`模块实现进程间的通信，

`child_process` 模块

### IPC
IPC 也就是我们常说的`inter process communition`   



### egg.cluster

#### cluster是什么
多进程模型，解决单核CPU问题，`egg-cluster`是用于 `egg` 多进程管理的基础模块，负责底层的`ICP`通道的简历以及各处理各个进程之间的通信。

`master`表示主进程
`worker`表示主进程`master`的子进程，一般是根据有多少个`CPU`启动多少个这样的进程，用于对外服务，处理各种业务层面的事情
`agent master`的子进程，主要处理公共资源的访问，像是文件的监听，或者是帮助worker处理一些公共事务，处理完后再通知worker

`master`类似于一个守护进程
① 负责 `agent` 的启动、退出、重启
② 负责各个 `worker` 进程的启动、退出、以及`fork`，在开发模式下负责重启
③ 负责 `agent` 和各个 `worker` 之间的通信
④ 负责各个worker之间的通信

master先启动agent，agent成功启动后通过回调通知master，然后master再根据CPU内核数目去启动worker

master和 agent/worker 是real 