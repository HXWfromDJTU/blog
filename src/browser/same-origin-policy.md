
## 前言
实习时第一次接触`浏览器同源策略`问题，是前后端准备联调需要访问后端Api，呆头呆脑的我再浏览器上发送了好久的 `xhr` 请求，却一直不成功.....头都麻了
![](/blog_assets/cross-origin-error.png)
一起实习的小伙伴让我在`Chrome`的启动程序上，加上`--disable-web-security`的小尾巴禁用掉同源策略，轻松加愉快地直接解决了问题......
![](/blog_assets/disable-web-security.png)
 
 作为`web`开发者，工作中不同阶段、不同场景都会遇到`跨域`的情况。这篇`笔记📒`在博客中也随着工作学习的推进，一次次地更新内容，更新自己对`跨域`这一问题的认识。

 以下内容最后更新于`2020.10`，前文内容略有删改。由于这个问题体系比较繁杂，本片文章仅涉及
 * `浏览器同源策略的由来`
 * `为什么要同源策略，不设置会有什么安全问题。`
 * `一些实战中遇到的跨域安全问题`

 想了解项目中如何进行跨域设置的小伙伴，请关注下一篇文章。

## 浏览器的同源策略
> 同源策略(same-origin policy)是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。   --- MDN

资源`URL`的以下三项中都相同时才认为两个资源是`同源的`
* `协议`: 比如http、https、ws、wss
* `域名`: 包括主域名和子域名，需要做到全匹配。
* `端口号`   

源与数据访问限制:       
* `localStorage`、`IndexedDB` 是浏览器常用的本地化存储方案，两者都是以源进行分割。每一个源下的脚本，都只能够访问同源中的缓存数据，不能实现跨域访问。 
* `Cookie`的匹配规则与上面二者又略有差异，主要差异在于`子域`的`cookie`会默认使用在`父域`上。详细的规则可以参考另一篇笔记 [浏览器原理 - 缓存之cookie](https://github.com/HXWfromDJTU/blog/issues/22)

## 同源策略中的安全



