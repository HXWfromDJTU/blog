## 前言
基于上一篇`cookie`的基本使用场景和用法，这回来记录下项目关于`cookie`中遇到的问题和解决方案。 

`cookie`解决的基本问题是`http`的无状态性，项目中大多数的场景也利用这个特性用于标记用户。    
* 登录后下发`auth token`标明用户的登录态。      
* 广告商下发`ssid token`，并通过整个`广告联盟`中的网站中上报的`ssid token`，收集用户的访问行为。    

## Cookie 与 Session
简单滴说，session 是什么呢？
* `Session`是一个临时的进程组群，目的是去完成一些任务，是直接存储在`内存`中的。    
* 每当`OS`接收到新任务的时候，就会调度进程去执行任务。
* 一个进程忙不过来就会继续调用其他进程或者创建子进程一起去执行，出现的这些进程会被分为一个个的进程组，最后这些共同完成任务的进程组一起可以被理解为一个`Session`会话。
* `Session` 一般有效期设置为`20min`，若超时时间内没有数据交互，服务器就会将`Session`对应的资源删除。       

### 传统 Session/Cookie 工作过程
1. 当客户端首次向服务端请求的时候，服务端维护一个`Session`，生成一个`sessionid`，值可以随意约定，就是一个用于标记session的值。

2. server 通过 http 响应客户端，客户端接收到了并保存在`Cookie`中。

3. 客户端结束掉了请求连接，服务端就会释放掉这些进程对资源的占用，本次会话的`状态`会被暂时保存在一个文件中，在一定的时间内，服务端会保留这个文件。

4. 在超时时间范围内，客户端每次访问该域名都会用`cookie`携带`sessionid`到服务端。服务端再根据`sessionid`找对应的`Session`，并且根据这个状态中记录的内容，打开对应的资源。      

<!-- 对于客户端来看，客户端后来每次去访问的时候都可以直接跳过了身份验证等重复操作，造成了好像服务器是一直在等待客户端的假象，其实服务器在连接断开的时候就释放掉了对应的进程资源。 -->

#### 存在的问题
* 客户端有可能禁用`cookie`
* 服务端使用内存存储用户信息，当用户数量增大的时候，内存肯定不够用
* 当服务端采用分布式部署的时候，用户的登录态 `Session` 并不能够被共享     
* 口令仍然保存在客户端，有可能被仿造 和 存在被盗用的风险     

我们来逐个解决下这些问题。


##### 使用 url query 代替 cookie 传参
* 在用户禁用`cookie`的情况下，用户访问服务器页面时，服务器可以下发token到前端，前端使用`cookie`以外的 web storage 技术进行 token 存储。    
* 前端请求后端接口时，从本地存储中取出 token 携带在请求参数中
    * GET 请求拼接在 url query 中
    * POST 请求可以放在 body 中

##### Session 与 高速缓存
* 当内存存储出现性能问题、并且会遇到分布式`Session`不能共享的问题时，高速缓存工具就是首选，比较热门的有 `Redis` `Memcached` 等    
* 缓存服务 与 引用服务将会保持长链接，而并非是频繁的短连接     
* 缓存服务 与 应用服务一般部署在同一个机房，访问速度受到网络影响一般比较小    

##### token 的结构与加密
* 添加客户端独有的信息作为加密的盐，比如用户访问时的`IP`或者`浏览器型号`等等。     
* `明文信息` = `随机生成字符串` + `客户端独有信息`后，通过服务端独有的私钥进行加密，最终生成下发的`token`   
* JWT 结构一般分为三个部分，使用`.`号分割
    * `Header`.`Payload`.`Signature`
    * Header 结构一般为
        ```json
          {
            "alg": "HS256",
            "typ": "JWT"
          }
        ```
     * Payload 部分则为需要保密的主要内容
        ```json
        {
            "user_id":"8192qhgb6kmoh3bypbc9wp146jusho",
            "session_id":"81928yaqk1sccfgwze4k718338z3ae",
            "platform":"wechat",
            "roles":"",
            "props": {"botId":"850444981"},
            "exp":1606291794,
            "iat":1603699794
        }
        ```
     * Signature 部分则是使用秘钥对前面二者的签名结果，`私钥`保存在服务器，以下是生成秘钥的示例。       
        `HMACSHA256(base64UrlEncode(header) + "." +base64UrlEncode(payload),secret)`
    
## 第三方cookie 与 隐私   

## websocket 与 cookie   


## 参考文章
[1] [JSON Web Token 入门教程](https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)     
