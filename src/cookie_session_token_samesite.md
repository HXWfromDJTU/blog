### cookie和session体系

我们知道`session`是一个临时的进程组群，目的是去完成一些任务。每当OS接收到新任务的时候，就会调度进程去执行任务，一个进程忙不过来就会继续调用其他进程或者创建紫禁城一起去执行，出现的这些进程会被分为一个个的进程组，最后这些共同完成任务的进程组一起可以被理解为一个`session`会话。

##### session+cookie工作过程
1️⃣ 当客户端首次向服务端请求的时候，服务端维护一个session，生成一个sessionid，值可以随意约定，就是一个用于标记session的值。

2️⃣ server通过http返回给客户端，客户端接收到了并保存在cookie中。

3️⃣ 客户端结束掉了请求连接，服务端就会释放掉这些进程对资源的占用，本次会话的`状态`会被暂时保存在一个文件中，在一定的时间内，服务端会保留这个文件。

4️⃣ 在超时时间范围内，客户端每次访问该域名都会用`cookie`携带`sessionid`到服务端，服务端再根据`sessionid`找回保存着记录状态的文件，再次为客户打开一个新的对话，并且根据这个状态中记录的内容，打开对应的资源。

对于客户端来看，客户端后来每次去访问的时候都可以直接跳过了身份验证等重复操作，造成了好像服务器是一直在等待客户端的假象，其实服务器在连接断开的时候就释放掉了对应的进程资源。

##### 优化改进(token)
`问题一`
session状态文件，在服务端是会占用服务端的资源和内存，所以服务端需要维护session的数目，以防内存的溢出。但是用户数目众多的时候，服务还是会因为要维护`session`而不堪重负。  

`问题二`
若使用分布式系统，那么跨服务器需要维护一个同一个`session`，则需要使用一个单独的`session`服务器去维持访问。一旦`session`崩溃，那么所有的用户状态都会丢失。

基于以上问题，我们可以使用`时间换空间`的思维，服务端不再保存`session`信息，而是将这部分信息进行编码后再加密，通过`cookie`返回给客户端，我们称之为`token`。下次用户再进行登录的时候，都携带`token`进行访问，服务端使用秘钥进行解密，若能够解开并且解编码成功，则说明这个`token`是之前服务器下发的，也就证明了这个客户端用户的合法性。