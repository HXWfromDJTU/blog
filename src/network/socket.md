# Socket
![](/blog_assets/socket_cover.png)

## 简要理解
1️⃣ 网络上的两个程序通过一个双向链接实现数据的交换，这个连接的一段被称之为`socket`。   

2️⃣ `socket`的本质是一个编程接口，对TCP/IP进行了封装，`TCP/IP`也要提供可供开发者做网络开发的接口。  

3️⃣ `HTTP`是轿车🚘，提供了封装或者显示数据的具体形式，`socket`是发动机，提供了网络通信的能力。    

4️⃣ 一台主机上多个端口，对应着不同的应用服务，每个服务都打开一个`socket`,并且绑定到一个端口上。   

5️⃣ 一台主机就像一个布满插座的房间，有的插座提供的是直流电，有的插座提供的是交流电，有的插座提供的是一个电视信号，用户通过插头插到不同的插座，就可以得到不同的服务。    

![](/blog_assets/socket.png)    




## 连接过程
根据连接启动的方式以及本地套接字要连接的目标，套接字之间的连接过程可以分为三个步骤：服务器监听，客户端请求，连接确认。

1️⃣ 服务器监听：是服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态。

2️⃣ 客户端请求：是指由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。

3️⃣ 连接确认：是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，它就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，连接就建立好了。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。





### 文件描述符  
![](/blog_assets/fd_terminal.png)
1️⃣ 在Linux中一切皆可以看成是文件，有`普通文件`、`目录文件`、`链接文件`和`设备文件`。  
2️⃣ 文件描述符是系统内核为了高效管理已经被打开的文件所创建的索引。  
3️⃣ 索引一般是小整数，所有执行I/O调用的系统操作都需要通过文件描述符号，文件描述符一般从3开始计算  
4️⃣ 程序刚启动的时候 0指代标准输入,1指代标准输出，2指代标准错误  
5️⃣ POSIX标准要求,每次打开文件的时候，都必须使用最小的可用序号

### 打开文件
1️⃣ 一般来说，系统有多少内存就可以打开多少文件，但是一般系统在底层配置的时候会做出限制，通常是系统内存的10%。  
2️⃣ 在进程级别上，系统也会限制一个进程能够打开的最大的文件数目，一般这个数目为`1024`，这个限制称之为用户级的限制。  
3️⃣ 一个文件描述符只能够指向一个文件，但是一个文件会有多个文件描述符去描述它。  
4️⃣ 同一个文件可以被一个进程中打开多次，也可以在不同进程中被打开  

⚠️ 若是同个进程中，多次打开同个文件，则在i-node表中会是同一个文件。   
⚠️ 若是不同进程下的文件描述符，都指向了同一个系统级下的文件句柄，那么很有可能是因为进程非fork造成的。或者是一个进程将UNIX下穿件的文件描述符，传递给另一个进程。

##### 进程级别的fd
1️⃣ 控制文件描述符的的一组标志  
2️⃣ 对打开文件起句柄的作用  

##### 系统级别的fd
1️⃣ 系统级别的文件描述符称之为：描述符表格  ，表格里的每个条目称之为：打开文件句柄。   

2️⃣ 一个打开状态下的文件句柄存储了一个与打开文件相关的全部信息  
* 当前文件的偏移量  
* 打开问件时使用的状态标准  
* 文件访问模式  
* 与信号相关的设置  
* 对文件i-node对象的引用  
* 文件类型  和 访问权限  
* 一个指向该文件锁列表的指针  
* 文件的各种属性  

3️⃣ 两个不同的文件描述符，若指向同一个打开文件句柄，将共享同一文件偏移量。因此，如果通过其中一个文件描述符来修改文件偏移量（由调用read()、write()或lseek()    

4️⃣  文件描述符标志（即，close-on-exec）为进程和文件描述符所私有。对这一标志的修改将不会影响同一进程或不同进程中的其他文件描述符  

查看自身机器最大可打开链接数目：
```
$ ulimit -n
```` 

![](/blog_assets/fd_compare.png)


## 参考资料
[1] [清华大学操作系统课程 - 文件描述符 - youtube](https://www.youtube.com/watch?v=H4AZXHkzPRM)


在双方通信之前，双方都需要建立一个socket,端到端的通信
包括网络层和传输层的一些参数 
TCP是基于数据流的，而UDP是基于数据包的。
指定 TCP还是UDP  SOCK_STREAM   SOCK_DGRAM
IPV-4 IPV-6  AF_INET 和 AF_INET6
bind函数
TCP有个listen状态
listen函数
维护两个队列:已经完成的队列
estabilsh状态
syn_rcvd状态

read 与 write

TCPde socke

写入和写出，就是读取这个文件描述符
文件描述符

发送队列 与 接收队列

socket在内核中就是一个文件
他就应该有文件描述符
每一个TCP链接都要占用一定的内存  

Linux 创建一个子进程 fork,进程复制的时候回把文件描述符列表全部拷贝一遍,也会复制内存空间，也会记录代码执行的位置
创建多线层，就可以共用文件描述符
IPC 进行通信？

线程会轻量级的多，办公家具可以共用。

C10K 一台机器要创建10K个链接，一亿个用户要10W台服务器
I/O多路复用，项目进度墙

I/O多路复用

epoll注册callback，某个文件描述符发生了变化
epoll函数

红黑树、平衡二叉树  随着输的节点更多，但是树的结构不会变得特别深   epoll entry 


服务端最大的连接数是 2的48次方   

fd_size  

win:IOCP

linux:epoll  通过callback的机制通知，可以突破最大文件描述符的限制  解决C10K问题的利器  




UDP 
sendTo receiveFrom 

客户端的IP数目 X 客户端的端口数目


创建子进程 fork 完完全全复制一个主进程，文件描述符的列表，内存空间，一条记录（指明当前执行到那一行）
