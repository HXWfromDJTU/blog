# Javascript 垃圾回收机制
![](/blog_assets/v8_gc.png)

## 前言

Javascript是一门具有垃圾回收机制的编程语言，程序员大部分情况下不用手动去操心内存管理的问题。

但是，`Javascript IN Browser`却是一个特殊的情况，分配给Web浏览器的空间一般会比分配给常用桌面程序的少，当然这是为了避免用户浏览网页也能够造成内存的溢出，甚至系统崩溃的情况。

但是限制内存的上限，相当于给一个武林高手绑上了手脚，会影响给变量声明时的内存分配，同时还会影响调用栈以及在一个线程中能够同时执行的`语句数量`。

## 手动清除
一旦数据不再使用，最好通过将其值设置为`null`来释放其引用，这个做法叫做`解除引用（dereferencing）`

一般会针对全局对象的属性进行解除引用操作，局部变量会在离开执行环境的时候自动被解除引用。

解除引用后并不会马上释放内存，只是相当于打上了一个标记，本轮GC回收的时候，会直接将指向`null`的数据原所占内存释放掉。

##### delete 补充
对于删除一个元素，我们已知常用的还有`delete`关键字   
* 常常用于删除对象上的一个属性，无论对应的属性值是一个对象，还是函数或是其他   
* 任何使用`let` `const` `var` `fun`声明的量，都不能都够使用`delete`去删除   
* 删除不能删除的量，执行器并不会报错，会返回一个`false`，然后相当无操作   
* 对于对象属性，若该属性配置了`configurable:false`，那么也是不能够被删除的。 

🚸 `delete`相对于`null`操作范围基本限定在对象的属性上，能够实现资源回收的优化也仅限于对象的属性上。

## 自动回收
### 标记清除法
标记清除是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。   

当变量进入环境，就将这个变量标记为`“进入环境”`，逻辑上进入环境的变量使用的可能性就很高，则肯定不能够将其所占用的内存释放掉。当变量离开环境的时候，则标记为“离开环境”，在下一轮清理时，释放其所占内存。
#### 过程
① GC回收器给在内存中的所有变量都加上标记

② 利用当前作用域链关系，给当前可能需要使用的变量去除标记

③ 在此后再被加上标记的变量被视为被删除掉的变量

④  垃圾回收器质性内存清除工作，销毁那些带标记的回收值，并回收他们的空间。
###  引用计数法
引用计数的主要思想是跟踪每一个值被引用的次数

#### 过程
① 当声明了一个变量，并将一个引用类型赋值给该变量时，则改变量的引用次数加`1`。     

② 当包含这个值引用的变量，被替换为另一个值，那么该值的引用次数减`1`。     

最后`GC`将引用次数为`0`的变量所占的内存空间清除。

#### 问题
① 引用计数法遇到循环引用的时候，就算后续不再使用，但是引用计数很难变为`0`，导致大量的内存得不到回收，为此，`Netscape`在4.0后放弃了引用计数法。
```js
function Person(){
    let objA= new Object();
    let objB = new Object();
    // 相互引用，形成循环
    objA.toB = objB;   
    objB.toA = objA;
}
```
② 引用计数法在`IE`中访问非原生`Javascript`对象(如`DOM`元素)时，这种算法仍然会导致问题。`IE 8`(包括)之前，针对`DOM`对象使用的还是引用计数法，当出现循环引用的时候，也会出现内存清除不正常的问题。

## Chrome V8垃圾回收

#### node中查看内存使用情况   
![](/blog_assets/node_memory_usage.png)
* heapTotal 和 heapUsed 代表 V8 的内存使用情况
* `external` 代表 V8 管理的，绑定到 `Javascript` 的 `C++` 对象的内存使用情况。
* `rss`： 全称是`resident set size`，是驻留集大小, 是给这个进程分配了多少物理内存（占总分配内存的一部分），包含所有的 C++ 和 JavaScript 对象与代码。

#### 基础设计
`Chrome`使用V8作为`Javascript`引擎，其`GC`回收机制也另有不同。     
* `V8`的内存分为`老生代`和`新生代`，`新生代`较小，用于保存新产生的小的对象，`老生代`用于保存大对象和经历多次回收仍未回收的对象       
* 建立一个列表用来记录所有老生代对象指向新生代对象的情况。

#### 对象的晋升机制     
* 若新生代的`To`空间已经占用了`25%`以上，那么新增的对象就直接进入老生代空间。    
* 若经过多次回收♻️仍未清除的对象，也会被移到`老生代`中。      


#### 老生代的清除算法
标记清除(Mark Sweep)策略 和 标记整理(Mark Compact)策略
前者分为标签和清除两个阶段，因为老生代中需要清除的内容很少，所以算法效率比较高，但是会产生很多内存碎片。所以就有了后面的Mark Compact，进行内存数据的移动，新晋对象但是内存不足的时候，就会触发。     

#### 新生代的清除算法
新生代使用Scavenge算法进行回收。在Scavenge算法的实现中，主要采用了Cheney算法。
执行过程大概为：
☢️ 首先将From空间中所有能从根对象到达的对象复制到To区
☢️ 再使用两个标记指针，去遍历这时候的To区域，若有发现有相关引用的对象，则做以下判断
☢️ 若该对象出现在老生代区，则不做操作，若该对象出现在新生代From区，则复制到To区，直到占用超过25%

## 内存泄漏常见的场景
#### 缓存的使用
开发时，我们经常会一个变量进行计算结果的缓存，缓存的变量又绑定在顶级属性上，也就导致了长期存活的对象越来越多。尽可能减少缓存变量的使用，可以减少垃圾回收算法执行时候的扫描时间。   

#### 闭包 与 全局变量
闭包的原理这里不再赘述，当闭包的引用挂载在全局下，而闭包本身没有被释放的情况下，则也可能会引起内存泄漏。

#### 定时器、事件使用后未移除
定时器 和 时间监听基本是JavaScript的常用工具，但常常是只记得用，不记得销毁。也可能导致内存泄漏。

## 如何对应避免内存泄漏
#### 浏览器
1. 首先是坏习惯之王：`定时器` 和 `事件监听` 要记得及时清除。
2. 对象之间尽量减少交叉，可以达到拆分对象，不创造大生命周期对象的效果。
3. 尽量不要手写闭包了

#### nodejs
1. Nodejs中尽量使用 `stream` 和 `buffer`来操作大文件
2. 尽量使用外部缓存工具来缓存大数据对象

## 参考资料
[1]《Javascript 高级程序设计 第三版》     
[2] [浅谈Chrome中的垃圾回收 -博客园](https://www.cnblogs.com/liangdaye/p/4654734.html)     
[3]《Nodejs深入浅出》     
[4] [javascript 中的 delete](https://justjavac.com/javascript/2013/04/04/understanding-delete-in-javascript.html)
