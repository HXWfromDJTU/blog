# 函数传参  


### js函数穿参是传值还是传引用？〔发散思维〕
首先我们给一个定论，是传值。而且所有情况都只传值。 

在函数传参的时候，内核是复制了一个栈帧的值作为形参的值，栈帧上存的是什么，那么我们就复制的是什么。    

##### `基本类型`     
在基本类型传参的时候，我们同样理解为拷贝栈帧，此时栈帧中保存的就是基本类型的值，比如说`123`，`true`，那么形参中的栈帧保存的也是一个这样的基本类型值。    

##### `引用类型`     
在传递引用类型的的时候。首先，实参在栈中存储的值就是一个指向堆中对应数据对象的`指针`，在传递函数参数的时候，将这个指针的值赋值了一份，作为形参的值。那么此时，形参的栈空间也存着一个值相同的指针，都指向了堆中的同一个对象。     
```js
// 原对象
let a = {key:123};

// 转换方式1
function change(b){
      b.key = 789;
}

// 转换方式2
function change2(c){
  c = {key2:888}
}
```
假设有以上的内容，我们开始进行操作
```js
change(a);     
console.log(a);   // {key:789}

change2(a);  
console.log(a)    // {key:789}
```
我们可以看出change操作中，访问到了a中的内容，并且进行了修改。而change2中的内容并没有修改成功。   

我来画一下当时的栈帧情况。        

|调用栈| 值 |
|---| --- |
| a|`xxx0081270xx`| 

|堆内存||
|---|--|
| `xxx0081270xx` |{key:123}|  

然后执行了函数`change`，进行了栈帧的拷贝,除了变量名字不同，值是完全的一致，所指向堆的位置也一致。也就不难明白为什么会修改到同一个对象了。                             
|调用栈||
|---| --- |
| a|`xxx0081270xx`| 
| b|`xxx0081270xx`|              

而当调用`change2`的时候，这时候是对c的值直接进行修改，也就是赋值了a的值(也就是那个内存地址)之后，我们又用一个新的内存地址覆盖了c的值。         

|调用栈||
|---| --- |
| a|`xxx0081270xx`| 
| c|`a762784368wqe`|              

|堆内存||
|---|--|
| `xxx0081270xx` |{key:789}|  
| `a762784368wqe` |{key:888}|     

所以到这里，我们坚定地继续喊出：JS函数调用的时候，形参的到的就是实参的值。           

但，这就结束了吗？其实我们还漏了一个特殊的基础类型...字符串  

##### `字符串`       
Javascript的字符串其实是具有不可变性，比如字符串累加添加内容，每一次操作其实在内存中都是新创建了一个操作后的字符串对象，操作之前的字符串对象也还在内存中，但马上会被GC回收。    
     
```js
var str = '123';
function change(str) {
  str = '456';
}
change(str);
console.log(str);//"123"
```
看起来表现和基本类型差不多，但实际上是在内存中另外开辟了一个空间，形参初始为`123`，被修改的空间是一个新的空间，和原来的实参`123`所在空间并不一样。       

     