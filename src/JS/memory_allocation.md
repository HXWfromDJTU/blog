# Javascript 变量存储

> 最近在`webpack`调试的时候遇到，经常遇到`heap oout of menory`的情况，导致调试开发工作的十分不顺利。所以决心了解一下`Javascript`和`node`的内存机制。

## 数据类型与存储空间
本篇文章先了解`Javascript In Browser`的内两种原始数据类型

| 类型 | 包含种类 | 存储情况 |
| --- | --- | --- |
| 原始值 | `String` `Number` `boolean` `null` `undefined` | 原始值存储在`栈`中    |
| 引用值 | `Object`  `Function` `Array` | 引用类型的指针存储在`栈`中，指向存在`堆`中的实际对象    |

### 堆与栈
| 栈(stack) | 描述 |
| --- | --- | --- |
| 结构 | 栈的优势就是存取速度比堆要快，仅次于直接位于CPU中的寄存器 |
| 值的变动 | 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本 |
| 大小与存活时间 | 所占内存空间大小、生命周期都是固定的 |

| 堆(heap) | 描述 |
| --- | --- | --- |
| 结构 | 因为在运行时动态分配内存，所以存取速度比较慢 |
| 值的变动 | 原地操作 |
| 大小与存活时间 | 可以动态地分配内存大小，生存期也不必事先告诉编译器 |

### 字符串的不可变性(举例)       
`Javascript`的字符串属于基础类型，每次往字符串中加添加内容，其实在内存中都是新创建了一个新字符串对象，旧字符串对象短时间也还在内存中，但马上会被GC回收。    
     
```js
var str = '123';

function change(str) {
  str = '456';
}

change(str);

console.log(str); //"123"
```
看起来表现和基本类型差不多，但实际上是在内存中另外开辟了一个空间，形参初始为`123`，被修改的空间是一个新的空间，和原来的实参`123`所在空间并不一样。 

## js函数传参是传值还是传引用？
首先我们给一个定论，是传值。而且所有情况都只传值。 

在函数传参的时候，内核是复制了一个栈帧的值作为形参的值，栈帧上存的是什么，那么我们就复制的是什么。    

##### `基本类型`     
在基本类型传参的时候，我们同样理解为拷贝栈帧，此时栈帧中保存的就是基本类型的值，比如说`123`，`true`，那么形参中的栈帧保存的也是一个这样的基本类型值。    

##### `引用类型`     
在传递引用类型的的时候。首先，实参在栈中存储的值就是一个指向堆中对应数据对象的`指针`，在传递函数参数的时候，将这个指针的值赋值了一份，作为形参的值。那么此时，形参的栈空间也存着一个值相同的指针，都指向了堆中的同一个对象。     
```js
// 原对象
let a = {key:123};

// 转换方式1
function change(b){
  b.key = 789;
}

// 转换方式2
function change2(c){
  c = {key2:888}
}
```
假设有以上的内容，我们开始进行操作
```js
change(a);     
console.log(a);   // {key:789}

change2(a);  
console.log(a)    // {key:789}
```
我们可以看出change操作中，访问到了a中的内容，并且进行了修改。而change2中的内容并没有修改成功。   

我来画一下当时的栈帧情况。        

|调用栈| 值 |
|---| --- |
| a|`xxx0081270xx`| 

|堆内存||
|---|--|
| `xxx0081270xx` |{key:123}|  

然后执行了函数`change`，进行了栈帧的拷贝,除了变量名字不同，值是完全的一致，所指向堆的位置也一致。也就不难明白为什么会修改到同一个对象了。                             
|调用栈||
|---| --- |
| a|`xxx0081270xx`| 
| b|`xxx0081270xx`|              

而当调用`change2`的时候，这时候是对c的值直接进行修改，也就是赋值了a的值(也就是那个内存地址)之后，我们又用一个新的内存地址覆盖了c的值。         

|调用栈||
|---| --- |
| a|`xxx0081270xx`| 
| c|`a762784368wqe`|              

|堆内存||
|---|--|
| `xxx0081270xx` |{key:789}|  
| `a762784368wqe` |{key:888}|     

所以到这里，我们坚定地继续喊出：`JS函数调用的时候，形参的到的就是实参的值`     


## 参考资料
[1] [图1 - 链接](https://blog.csdn.net/pingfan592/article/details/55189622)


<!-- ## 类型判断
想要确定一个值是哪种`基本类型`，可以使用`typeof`运算符
```js
typeof(123) // "number"
typeof("aaa") // "string"
typeof({})  // "object"
typeof([])  // "object"
typeof(function(){}) //"function"
```
想确定一个值是那种引用类型可以使用`instanceof`操作符
```js
function Q(){}
let qqq = new Q();
// 判断 qqq 是实例对象
qqq instanceof Q; // true
qqq instanceof Object // true
qqq instanceof Function // false
qqq instanceof Array // false
```
### 实例与比较
```js
var a1 = 0;   // 变量对象
var a2 = 'this is string'; // 变量对象
var a3 = null; // 变量对象

var b = { m: 20 }; // 变量b存在于变量对象中，{m: 20} 作为对象存在于堆内存中
var c = [1, 2, 3]; // 变量c存在于变量对象中，[1, 2, 3] 作为对象存在于堆内存中
```
![](/blog_assets/stack_heap.png)
<div style="text-align:center;">变量对象与堆内存(图①)</div> -->
