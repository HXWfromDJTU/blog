# Javascript 垃圾回收机制
![](/blog_assets/v8_gc.png)
___
Javascript是一门具有垃圾回收机制的编程语言，程序员大部分情况下不用手动去操心内存管理的问题。

但是，`Javascript IN Browser`却是一个特殊的情况，分配给Web浏览器的空间一般会比分配给常用桌面程序的少，当然这是为了避免用户浏览网页也能够造成内存的溢出，甚至系统崩溃的情况。

但是限制内存大下上限，相当于给一个武林高手绑上了手脚，会影响给变量声明时的内存分配，同事还会影响调用栈以及在一个线程中能够同时执行的`语句数量`。

### 手动清除
一旦数据不再使用，最好通过将其值设置为`null`来释放其引用，这个做法叫做`解除引用（dereferencing）`

一般会针对全局对象的属性进行解除引用操作，局部变量会在离开执行环境的时候自动被解除引用。

解除引用后并不会马上释放内存，只是相当于打上了一个标记，本轮GC回收的时候，会直接将指向`null`的数据原所占内存释放掉。

##### delete 补充
对于删除一个元素，我们已知常用的还有`delete`关键字   
1️⃣ 常常用于删除对象上的一个属性，无论对应的属性值是一个对象，还是函数或是其他   
2️⃣ 任何使用`let` `const` `var` `fun`声明的量，都不能都够使用`delete`去删除   
3️⃣ 删除不能删除的量，执行器并不会报错，会返回一个`false`，然后相当无操作   
4️⃣ 对于对象属性，若该属性配置了`configurable:false`，那么也是不能够被删除的。 

🚸 `delete`相对于`null`操作范围基本限定在对象的属性上，能够实现资源回收的优化也仅限于对象的属性上。
___
### 自动回收
##### 标记清除法
标记清除是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。
当变量进入环境，就将这个变量标记为`“进入环境”`，逻辑上进入环境的变量使用的可能性就很高，则肯定不能够将其所占用的内存释放掉。当变量离开环境的时候，则标记为“离开环境”，在下一轮清理时，释放其所占内存。
###### 过程
① GC回收器给在内存中的所有变量都加上标记

② 利用当前作用域链关系，给当前可能需要使用的变量去除标记

③ 在此后再被加上标记的变量被视为被删除掉的变量

④  垃圾回收器质性内存清除工作，销毁那些带标记的回收值，并回收他们的空间。
#####  引用计数法
引用计数的主要思想是跟踪每一个值被引用的次数

当声明了一个变量，并将一个引用类型赋值给该变量时，则改变量的引用次数加`1`。
当包含这个值引用的变量，被替换为另一个值，那么该值的引用次数减`1`。

最后`GC`将引用次数为0的变量所占的内存空间清除。

###### 问题
① 引用计数法遇到循环引用的时候，就算后续不再使用，但是引用计数很难变为`0`，导致大量的内存得不到回收，为此，`Netscape`在4.0后放弃了引用计数法。
```js
function Person(){
    let objA= new Object();
    let objB = new Object();
    // 相互引用，形成循环
    objA.toB = objB;   
    objB.toA = objA;
}
```
② 引用计数法在`IE`中访问非原生`Javascript`对象(如`DOM`元素)时，这种算法仍然会导致问题。`IE 8`(包括)之前，针对`DOM`对象使用的还是引用计数法，当出现循环引用的时候，也会出现内存清除不正常的问题。
___
### Chrome V8垃圾回收
Chrome使用V8作为Javascript引擎，其GC回收机制也另有不同。
1️⃣ V8的内存分为老生带和新生代，新生代较小，用于保存新产生的小的对象，老生代用于保存大对象和经历多次回收仍未回收的对象  
2️⃣ 建立一个列表用来记录所有老生代对象指向新生代对象的情况。
3️⃣ 存在对象的晋升机制  
一：若新生代的To空间已经占用了25%以上，那么新增的对象就直接进入老生代空间。    
二：若经过多次回收♻️仍未清楚的对象，也会被移到老生代中。  
##### 4️⃣ 老生代的清除算法
标记清除(Mark Sweep)策略 和 标记整理(Mark Compact)策略
前者分为标签和清除两个阶段，因为老生代中需要清除的内容很少，所以算法效率比较高，但是会产生很多内存碎片。所以就有了后面的Mark Compact，进行内存数据的移动，新晋对象但是内存不足的时候，就会触发。
##### 5️⃣ 新生代的清除算法
新生代使用Scavenge算法进行回收。在Scavenge算法的实现中，主要采用了Cheney算法。
执行过程大概为：
☢️ 首先将From空间中所有能从根对象到达的对象复制到To区
☢️ 再使用两个标记指针，去遍历这时候的To区域，若有发现有相关引用的对象，则做以下判断
☢️ 若该对象出现在老生代区，则不做操作，若该对象出现在新生代From区，则复制到To区，直到占用超过25%

___
### 参考资料
《Javascript 高级程序设计 第三版》

[浅谈Chrome中的垃圾回收 -博客园](https://www.cnblogs.com/liangdaye/p/4654734.html)

《Nodejs深入浅出》

[javascript 中的 delete](https://justjavac.com/javascript/2013/04/04/understanding-delete-in-javascript.html)